# galigo Live Integration Tests
#
# TRIGGER MATRIX:
#   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   â”‚ Trigger             â”‚ Suite   â”‚ Timeout â”‚ Environment         â”‚
#   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
#   â”‚ Daily schedule      â”‚ smoke   â”‚ 15 min  â”‚ telegram-smoke      â”‚
#   â”‚ Manual (default)    â”‚ all     â”‚ 60 min  â”‚ telegram-live       â”‚
#   â”‚ Manual â†’ smoke      â”‚ smoke   â”‚ 15 min  â”‚ telegram-live       â”‚
#   â”‚ Manual â†’ other      â”‚ choice  â”‚ 60 min  â”‚ telegram-live       â”‚
#   â”‚ Release published   â”‚ all     â”‚ 60 min  â”‚ telegram-live       â”‚
#   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
# ENVIRONMENT SETUP REQUIRED:
#   1. telegram-smoke: No required reviewers (for unattended schedule)
#   2. telegram-live:  Required reviewers = you (for manual/release)
#   Both need: TESTBOT_ENV secret
#
name: Live Integration Tests

on:
  schedule:
    - cron: '15 5 * * *'

  release:
    types: [published]

  workflow_dispatch:
    inputs:
      suite:
        description: 'Test suite to run'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - smoke
          - core
          - media
          - keyboards
          - interactive
          - chat-admin
          - stickers
          - stars

concurrency:
  group: telegram-live
  cancel-in-progress: false

permissions:
  contents: read
  issues: write  # For failure notification

jobs:
  integration-test:
    name: >-
      ${{
        github.event_name == 'schedule' && 'â° Smoke Test' ||
        github.event_name == 'release' && format('ðŸš€ Release {0}', github.event.release.tag_name) ||
        format('ðŸ§ª {0}', inputs.suite)
      }}
    runs-on: ubuntu-latest

    # CRITICAL: Dynamic environment selection
    # - Schedule uses 'telegram-smoke' (NO approval required - runs unattended)
    # - Manual/Release uses 'telegram-live' (approval required - human triggered)
    environment: ${{ github.event_name == 'schedule' && 'telegram-smoke' || 'telegram-live' }}

    if: github.repository_owner == 'prilive-com'

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit
          allowed-endpoints: >
            api.telegram.org:443
            github.com:443
            api.github.com:443
            proxy.golang.org:443
            sum.golang.org:443
            storage.googleapis.com:443

      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Build testbot
        run: go build -o galigo-testbot ./cmd/galigo-testbot

      - name: Configure environment
        env:
          TESTBOT_ENV: ${{ secrets.TESTBOT_ENV }}
        run: |
          set -euo pipefail
          printf '%s\n' "$TESTBOT_ENV" > .env

      - name: Determine test suite
        id: config
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"

          case "$EVENT" in
            schedule)
              SUITE="smoke"
              TIMEOUT=15
              ;;
            release)
              SUITE="all"
              TIMEOUT=60
              ;;
            workflow_dispatch)
              SUITE="${{ inputs.suite }}"
              if [[ "$SUITE" == "smoke" ]]; then
                TIMEOUT=15
              else
                TIMEOUT=60
              fi
              ;;
            *)
              SUITE="smoke"
              TIMEOUT=15
              ;;
          esac

          echo "suite=$SUITE" >> $GITHUB_OUTPUT
          echo "timeout=$TIMEOUT" >> $GITHUB_OUTPUT

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Suite:   $SUITE"
          echo "  Timeout: ${TIMEOUT}m"
          echo "  Trigger: $EVENT"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Run ${{ steps.config.outputs.suite }} tests
        run: ./galigo-testbot --run "${{ steps.config.outputs.suite }}"
        timeout-minutes: ${{ fromJSON(steps.config.outputs.timeout) }}

      - name: Upload reports
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: testbot-${{ steps.config.outputs.suite }}-${{ github.run_number }}
          path: var/*.json
          retention-days: 90
          if-no-files-found: warn

      - name: Generate summary
        if: always()
        run: |
          set -euo pipefail
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ¤– Testbot Results

          | Property | Value |
          |----------|-------|
          | **Suite** | \`${{ steps.config.outputs.suite }}\` |
          | **Trigger** | \`${{ github.event_name }}\` |
          | **Timeout** | ${{ steps.config.outputs.timeout }} min |
          | **Environment** | \`${{ github.event_name == 'schedule' && 'telegram-smoke' || 'telegram-live' }}\` |
          | **Run** | #${{ github.run_number }} |
          EOF

          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "| **Release** | \`${{ github.event.release.tag_name }}\` |" >> $GITHUB_STEP_SUMMARY
          fi

  # Separate job for failure notification
  # Why separate? If main job times out, inline steps won't run
  notify-failure:
    name: ðŸš¨ Notify Failure
    runs-on: ubuntu-latest
    needs: integration-test
    if: failure() && github.repository_owner == 'prilive-com'

    steps:
      - name: Create failure issue
        uses: actions/github-script@v8
        with:
          script: |
            const title = `ðŸš¨ Integration test failed (${context.eventName})`;
            const body = `
            ## Test Failure Report

            | Property | Value |
            |----------|-------|
            | **Trigger** | \`${context.eventName}\` |
            | **Run** | [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) |
            | **Ref** | \`${context.ref}\` |
            | **SHA** | \`${context.sha.substring(0, 7)}\` |

            Please investigate the failure.
            `;

            // Check for existing open issue to avoid duplicates
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure',
              per_page: 10
            });

            const existingIssue = issues.data.find(i =>
              i.title.startsWith('ðŸš¨ Integration test failed')
            );

            if (existingIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: body
              });
              console.log(`Added comment to issue #${existingIssue.number}`);
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['ci-failure', 'bot']
              });
              console.log('Created new failure issue');
            }
